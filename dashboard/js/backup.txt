
function showPaneContent(id) {
    const raw = blockTexts[id] || "No details available.";
    let html = autoLink(raw);

    // Step 1: Wrap timestamp sections into posts
    // html = html.replace(
    //     /(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:)([\s\S]*?)(?=(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:)|$)/g,
    //     (match, timestamp, content) => `<span class="post">${timestamp}${content}</span>`
    // );

    // Step 1: Wrap timestamp sections into posts and timestamp span
    html = html.replace(
        /(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):([\s\S]*?)(?=(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:)|$)/g,
        (match, year, month, day, hour, minute, content) => {
            const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
                "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            const displayDate = `${day} ${monthNames[parseInt(month, 10) - 1]} ${year}, ${hour}:${minute}`;
            return `<span class="post"><span class="timestamp">${displayDate}</span>${content}</span>`;
        }
    );


    // Step 2: Parse HTML to DOM so we can safely combine Manage + Labels
    const container = document.createElement("div");
    container.innerHTML = html;

    // Find Manage or Labels text nodes/elements
    let manageNode = null, labelsNode = null;

    [...container.childNodes].forEach(node => {
        if (node.nodeType === Node.ELEMENT_NODE) {
            const txt = node.innerHTML || node.textContent;
            if (/^Manage:/i.test(txt.trim())) manageNode = node;
            if (/^Labels:/i.test(txt.trim())) labelsNode = node;
        } else if (node.nodeType === Node.TEXT_NODE) {
            const txt = node.textContent.trim();
            if (/^Manage:/i.test(txt.trim())) {
                const manageDiv = collectManageBlock(node);
                node.remove();
                manageNode = manageDiv;
            }

            if (/^Labels:/i.test(txt.trim())) {
                const span = document.createElement("div");
                span.className = "labels";
                const labelText = txt.replace(/^Labels:\s*/i, "");
                const labelSpans = splitLabelsRespectingQuotes(labelText)
                    .map(l => `<span class="label">${l}</span>`)
                    .join(" ");
                span.innerHTML = "Labels: " + labelSpans;
                node.replaceWith(span);
                labelsNode = span;
            }

        }
    });

    // If either exists, group into one .meta
    if (manageNode || labelsNode) {
        const meta = document.createElement("span");
        meta.className = "meta";
        if (manageNode) meta.appendChild(manageNode);
        if (labelsNode) meta.appendChild(labelsNode);
        // Insert meta at the start
        container.insertBefore(meta, container.firstChild);
    }

    document.getElementById("paneContent").innerHTML = container.innerHTML;

    const pane = document.getElementById("paneContent");

    // Remove any old animation class
    pane.classList.remove("pane-animate");

    // Force reflow so the animation restarts
    void pane.offsetWidth;

    // Add class back to trigger animation
    pane.classList.add("pane-animate");





}



